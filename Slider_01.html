<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Slider Poem Navigator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        body { 
            margin: 0; 
            font-family: Arial, sans-serif; 
            overflow: hidden;
            background: #f5f5f5;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
        }
        .control-btn {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #file-input { display: none; }
    </style>
</head>


<body>
    <div id="controls">
        <button class="control-btn" onclick="loadNewCSV()">Load New CSV</button>
        <input type="file" id="file-input" accept=".csv">
    </div>



    <script>
        // ==========================================
        // CONFIGURATION MODULE
        // ==========================================
        
        const CONFIG = {
            // Circular slider settings
            circularSlider: {
                centerX: null,  // Will be set to windowWidth/2 in setup
                centerY: null,  // Will be set to windowHeight/2 in setup
                radius: 350,    // Radius of the circular slider
                handleRadius: 15, // Radius of the red draggable circle
                handleColor: [220, 50, 50], // Red color for handle
                trackColor: [200, 200, 200], // Gray for track
                trackWidth: 2,
                pointRadius: 5, // Radius of the equidistant points
                pointColor: [100, 100, 255], // Blue color for points
                snapThreshold: 0.55 // Angle threshold for snapping (in radians)
            },
            
            // Animation settings
            animation: {
                transitionSpeed: 0.1, // Lerp speed for smooth transitions
                floatingSpeed: 0.02,
                floatingAmplitude: 1.5
            },
            
            // Node sizing
            nodeSizing: {
                wordCharMultiplier: 3,
                wordMinRadius: 15,
                stropheWordMultiplier: 2,
                stropheMinRadius: 25,
                lineRadius: 25,
                poemRadius: 40
            }
        };

        // ==========================================
        // MULTI-POEM DATA MANAGEMENT MODULE
        // ==========================================
        
        // Three different poems
        const poemData = [
            {
                title: "Poem 1 - Strategy",
                csv: `Strophe,Line,Words
		1,1,Los objetivos de esta estrategia son pardo
		1,2,La idea es potencialmente hacerlo 
		1,3,Dada su natur el riesgo de no ser transmitidos
		,,
		2,1, facilitar la comprensión de los distintos ardo
		2,2,oner en como una vitrina creativa y d
		2,3,"aleza experimental y multimedia, muchos aspectos corren
		,,
		3,1,"istintos tipos de contenido: imágenes, video, bardo
		3,2,es por ello que se debe abordar la difusión con d
		3,3,llegar a conocimiento de galeristas o curadores.`
            },
            {
                title: "Poem 2 - Nature",
                csv: `Strophe,Line,Words
		1,1,The morning dew glistens on emerald leaves today
		1,2,Birds sing melodies that dance through the air
		1,3,Sunlight filters through ancient oak branches above
		,,
		2,1,Rivers flow with whispered secrets of time
		2,2,Mountains stand as guardians of the earth
		2,3,Flowers bloom in vibrant colors everywhere
		,,
		3,1,Wind carries stories from distant lands far
		3,2,Stars shine like diamonds in the night sky
		3,3,Nature speaks in languages we must learn.`
            },
            {
                title: "Poem 3 - Intensidad y altura",
                csv: `Strophe,Line,Words
		1,1,Quiero escribir pero me sale espuma
		1,2,quiero decir muchísimo y me atollo
		1,3,no hay cifra hablada que no sea suma
		1,4,no hay pirámide escrita sin cogollo
		,,
		2,1,Quiero escribir pero me siento puma
		2,2,quiero laurearme pero me encebollo
		2,3,No hay toz hablada que no llegue a bruma
		2,4,no hay dios ni hijo de dios, sin desarrollo
		,,
		3,1,Virtual reality opens new dimensional doors
		3,2,Quantum computers solve mysteries of existence
		3,3,Technology bridges past and future together.`
            }
        ];

        // Current state variables
        let currentPoemIndex = 0;
        let targetPoemIndex = 0;
        let poemDiagrams = []; // Array to store diagram data for each poem
        let viewportOffset = 0; // Horizontal offset for diagram viewing
        let targetOffset = 0; // Target offset for smooth transitions
        
        /**
         * Parses CSV data for a specific poem and creates hierarchical structure
         * @param {string} csvText - CSV formatted text
         * @param {number} poemIndex - Index of the poem
         * @returns {object} Parsed data structure with strophes, lines, and words
         */
        function parseCSVForPoem(csvText, poemIndex) {
            const data = { strophes: {}, lines: {}, words: [] };
            const lines = csvText.trim().split('\n');
            
            // Skip header and process each line - forEach callback iteration
            lines.slice(1).forEach((line, index) => {
                const trimmedLine = line.trim();
                if (trimmedLine === '' || trimmedLine === ',,') return;
                
                const parts = trimmedLine.split(',');
                const strophe = parts[0] ? parseInt(parts[0]) : null;
                const lineNum = parts[1] ? parseInt(parts[1]) : null;
                const wordsText = parts.slice(2).join(',').replace(/"/g, '').trim();
                
                if (strophe && lineNum && wordsText) {
                    const lineId = `${strophe}-${lineNum}`;
                    
                    if (!data.strophes[strophe]) {
                        data.strophes[strophe] = [];
                    }
                    
                    if (!data.lines[lineId]) {
                        data.lines[lineId] = {
                            strophe: strophe,
                            line: lineNum,
                            words: []
                        };
                        data.strophes[strophe].push(lineId);
                    }
                    
                    // Split words and create word objects - forEach callback iteration
                    const words = wordsText.split(' ').filter(w => w.length > 0);
                    words.forEach(word => {
                        const wordObj = {
                            text: word,
                            lineId: lineId,
                            strophe: strophe
                        };
                        data.words.push(wordObj);
                        data.lines[lineId].words.push(wordObj);
                    });
                }
            });
            
            return data;
        }

        /**
         * Initializes all three poem diagrams
         * Creates data structures and node positions for each poem
         */
        function initializeAllPoems() {
            poemDiagrams = [];
            
            // forEach callback to create diagram for each poem
            poemData.forEach((poem, index) => {
                const data = parseCSVForPoem(poem.csv, index);
                const diagramWidth = windowWidth;
                const offsetX = index * diagramWidth;
                
                poemDiagrams.push({
                    data: data,
                    nodes: [],
                    springs: [],
                    currentState: 'initial',
                    selectedNode: null,
                    offsetX: offsetX,
                    title: poem.title
                });
            });
            
            // Create nodes and connections for each diagram - forEach callback
            poemDiagrams.forEach((diagram, index) => {
                createNodesForDiagram(diagram, index);
                createConnectionsForDiagram(diagram);
                LayoutManager.arrangeCircularForDiagram(diagram);
            });
        }

        /**
         * File loading functionality - callback function for file input change
         */
        function loadNewCSV() {
            document.getElementById('file-input').click();
        }

        // Event listener for file input change - callback function
        document.getElementById('file-input').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                // Callback for file load completion
                reader.onload = function(e) {
                    poemData[currentPoemIndex].csv = e.target.result;
                    initializeAllPoems();
                };
                reader.readAsText(file);
            }
        });

        // ==========================================
        // CIRCULAR SLIDER MODULE
        // ==========================================
        
        /**
         * CircularSlider class manages the circular navigation interface
         * Handles the draggable red handle and three equidistant points
         */
        class CircularSlider {
            constructor() {
                this.centerX = CONFIG.circularSlider.centerX;
                this.centerY = CONFIG.circularSlider.centerY;
                this.radius = CONFIG.circularSlider.radius;
                this.handleRadius = CONFIG.circularSlider.handleRadius;
                
                // Current angle of the handle (in radians)
                this.currentAngle = 0;
                this.targetAngle = 0;
                
                // Is the handle being dragged?
                this.isDragging = false;
                
                // Calculate three equidistant points (120 degrees apart)
                this.poemAngles = [
                    0,                    // Poem 1: 0 degrees (right)
                    TWO_PI / 3,          // Poem 2: 120 degrees
                    (TWO_PI / 3) * 2     // Poem 3: 240 degrees
                ];
                
                // Points positions (calculated once)
                this.poemPoints = this.poemAngles.map(angle => ({
                    x: this.centerX + cos(angle) * this.radius,
                    y: this.centerY + sin(angle) * this.radius,
                    angle: angle
                }));
            }
            
            /**
             * Updates the slider position and checks for snapping
             */
            update() {
                // Smooth transition to target angle
                this.currentAngle = this.lerpAngle(
                    this.currentAngle, 
                    this.targetAngle, 
                    CONFIG.animation.transitionSpeed
                );
                
                // Check if close to any poem point and snap if needed
                if (!this.isDragging) {
                    this.checkSnapping();
                }
            }
            
            /**
             * Draws the circular slider interface
             */
            draw() {
                push();
                
                // Draw the circular track
                stroke(CONFIG.circularSlider.trackColor);
                strokeWeight(CONFIG.circularSlider.trackWidth);
                noFill();
                ellipse(this.centerX, this.centerY, this.radius * 2, this.radius * 2);
                
                // Draw the three equidistant points (poem positions)
                this.poemPoints.forEach((point, index) => {
                    fill(CONFIG.circularSlider.pointColor);
                    noStroke();
                    ellipse(point.x, point.y, CONFIG.circularSlider.pointRadius * 2);
                    
                    // Draw poem number
                    fill(50);
                    textAlign(CENTER, CENTER);
                    textSize(12);
                    const labelOffset = 25;
                    const labelX = this.centerX + cos(point.angle) * (this.radius + labelOffset);
                    const labelY = this.centerY + sin(point.angle) * (this.radius + labelOffset);
                    text(`P${index + 1}`, labelX, labelY);
                });
                
                // Draw the draggable handle (red circle)
                const handleX = this.centerX + cos(this.currentAngle) * this.radius;
                const handleY = this.centerY + sin(this.currentAngle) * this.radius;
                
                fill(CONFIG.circularSlider.handleColor);
                stroke(255);
                strokeWeight(2);
                ellipse(handleX, handleY, this.handleRadius * 2);
                
                pop();
            }
            
            /**
             * Checks if handle is close to any poem point and snaps to it
             */
            checkSnapping() {
                const threshold = CONFIG.circularSlider.snapThreshold;
                
                // Check each poem angle - forEach callback
                this.poemAngles.forEach((angle, index) => {
                    const angleDiff = this.getAngleDifference(this.currentAngle, angle);
                    
                    // If close enough, snap to that poem
                    if (abs(angleDiff) < threshold) {
                        this.targetAngle = angle;
                        
                        // Update target poem if different
                        if (targetPoemIndex !== index) {
                            targetPoemIndex = index;
                            targetOffset = -targetPoemIndex * windowWidth;
                        }
                    }
                });
            }
            
            /**
             * Handles mouse press to start dragging
             */
            onMousePressed() {
                const handleX = this.centerX + cos(this.currentAngle) * this.radius;
                const handleY = this.centerY + sin(this.currentAngle) * this.radius;
                const d = dist(mouseX, mouseY, handleX, handleY);
                
                // Start dragging if clicked on handle
                if (d < this.handleRadius) {
                    this.isDragging = true;
                }
            }
            
            /**
             * Handles mouse drag to move the handle along the circle
             */
            onMouseDragged() {
                if (this.isDragging) {
                    // Calculate angle from center to mouse position
                    const angle = atan2(mouseY - this.centerY, mouseX - this.centerX);
                    this.currentAngle = angle;
                    this.targetAngle = angle;
                }
            }
            
            /**
             * Handles mouse release to stop dragging
             */
            onMouseReleased() {
                this.isDragging = false;
            }
            
            /**
             * Linear interpolation for angles (handles wrap-around)
             */
            lerpAngle(a, b, t) {
                let diff = b - a;
                // Normalize to [-PI, PI]
                while (diff > PI) diff -= TWO_PI;
                while (diff < -PI) diff += TWO_PI;
                return a + diff * t;
            }
            
            /**
             * Gets the shortest difference between two angles
             */
            getAngleDifference(a, b) {
                let diff = b - a;
                while (diff > PI) diff -= TWO_PI;
                while (diff < -PI) diff += TWO_PI;
                return diff;
            }
        }

        // ==========================================
        // ANIMATION AND FLOATING MODULE
        // ==========================================
        
        /**
         * FloatingAnimation class creates subtle floating motion for nodes
         */
        class FloatingAnimation {
            constructor() {
                this.time = 0;
                this.speed = CONFIG.animation.floatingSpeed;
                this.amplitude = CONFIG.animation.floatingAmplitude;
            }

            /**
             * Updates the animation time
             */
            update() {
                this.time += this.speed;
            }

            /**
             * Gets the floating offset for a specific node
             * @param {string} nodeId - Unique identifier for the node
             * @returns {object} Object with x and y offset values
             */
            getOffset(nodeId) {
                const hash = this.hashCode(nodeId.toString());
                const xOffset = sin(this.time + hash * 0.1) * this.amplitude;
                const yOffset = cos(this.time * 1.3 + hash * 0.2) * this.amplitude;
                return { x: xOffset, y: yOffset };
            }

            /**
             * Simple hash function to create unique patterns per node
             */
            hashCode(str) {
                let hash = 0;
                // for loop to calculate hash from string
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash;
            }
        }

        // ==========================================
        // NODE CLASS MODULE
        // ==========================================
        
        /**
         * Node class represents individual elements in the network diagram
         * Can be: poem, strophe, line, or word
         */
        class Node {
            constructor(x, y, text, type, id, diagramIndex = 0) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.initialX = x;
                this.initialY = y;
                this.text = text;
                this.type = type;
                this.id = id;
                this.diagramIndex = diagramIndex;
                this.opacity = 1.0;
                this.targetOpacity = 1.0;
                this.connections = [];
                this.isOrdered = false;
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                
                // Calculate radius based on content and type
                this.radius = this.calculateRadius();
            }
            
            /**
             * Calculates circle radius based on node type and content
             * Words: based on character count
             * Strophes: based on total word count
             */
            calculateRadius() {
                if (this.type === 'word') {
                    return max(
                        CONFIG.nodeSizing.wordMinRadius, 
                        this.text.length * CONFIG.nodeSizing.wordCharMultiplier + 10
                    );
                } else if (this.type === 'strophe') {
                    const diagram = poemDiagrams[this.diagramIndex];
                    if (diagram && diagram.data.strophes[this.id]) {
                        let wordCount = 0;
                        // forEach callback to count words in strophe
                        diagram.data.strophes[this.id].forEach(lineId => {
                            if (diagram.data.lines[lineId]) {
                                wordCount += diagram.data.lines[lineId].words.length;
                            }
                        });
                        return max(
                            CONFIG.nodeSizing.stropheMinRadius, 
                            wordCount * CONFIG.nodeSizing.stropheWordMultiplier + 20
                        );
                    }
                    return CONFIG.nodeSizing.stropheMinRadius;
                } else if (this.type === 'line') {
                    return CONFIG.nodeSizing.lineRadius;
                } else if (this.type === 'poem') {
                    return CONFIG.nodeSizing.poemRadius;
                }
                return 20;
            }
            
            /**
             * Returns color array based on node type
             */
            getColor() {
                const colors = {
                    'poem': [200, 50, 200],
                    'strophe': [255, 100, 100],
                    'line': [100, 150, 255],
                    'word': [150, 255, 150]
                };
                return colors[this.type];
            }
            
            /**
             * Updates node position with smooth animation and floating effect
             */
            update() {
                if (!this.isDragging) {
                    const floatingOffset = floatingAnim.getOffset(this.id);
                    this.x = lerp(this.x, this.targetX + floatingOffset.x, 0.15);
                    this.y = lerp(this.y, this.targetY + floatingOffset.y, 0.15);
                }
                this.opacity = lerp(this.opacity, this.targetOpacity, 0.1);
            }
            
            /**
             * Draws the node as a circle with text inside
             */
            draw() {
                push();
                
                // Apply diagram offset for horizontal positioning
                translate(viewportOffset + poemDiagrams[this.diagramIndex].offsetX, 0);
                
                const color = this.getColor();
                
                // Draw circle
                fill(color[0], color[1], color[2], this.opacity * 180);
                stroke(50, this.opacity * 255);
                strokeWeight(2);
                ellipse(this.x, this.y, this.radius * 2, this.radius * 2);
                
                // Draw text
                fill(50, this.opacity * 255);
                noStroke();
                textAlign(CENTER, CENTER);
                
                const textSizeValue = map(this.radius, 15, 60, 10, 16);
                textSize(textSizeValue);
                if (this.type === 'poem') textStyle(BOLD);
                
                // Wrap text for small circles
                const words = this.text.split(' ');
                if (words.length > 1 && this.radius < 40) {
                    const lineHeight = textSizeValue + 2;
                    const totalHeight = words.length * lineHeight;
                    let startY = this.y - totalHeight / 2 + lineHeight / 2;
                    
                    // forEach callback to draw each word on separate line
                    words.forEach((word, i) => {
                        text(word, this.x, startY + i * lineHeight);
                    });
                } else {
                    text(this.text, this.x, this.y);
                }
                
                pop();
            }
            
            /**
             * Checks if mouse position is inside the node
             */
            contains(mx, my) {
                const adjustedMx = mx - viewportOffset - poemDiagrams[this.diagramIndex].offsetX;
                const distance = dist(adjustedMx, my, this.x, this.y);
                return distance <= this.radius;
            }
            
            /**
             * Sets target position and opacity for smooth transitions
             */
            setTarget(x, y, opacity = 1.0) {
                this.targetX = x;
                this.targetY = y;
                this.targetOpacity = opacity;
            }

            /**
             * Starts dragging the node
             */
            startDrag(mx, my) {
                this.isDragging = true;
                const adjustedMx = mx - viewportOffset - poemDiagrams[this.diagramIndex].offsetX;
                this.dragOffset.x = this.x - adjustedMx;
                this.dragOffset.y = this.y - my;
            }

            /**
             * Updates position during drag
             */
            updateDrag(mx, my) {
                if (this.isDragging) {
                    const adjustedMx = mx - viewportOffset - poemDiagrams[this.diagramIndex].offsetX;
                    this.x = adjustedMx + this.dragOffset.x;
                    this.y = my + this.dragOffset.y;
                    this.targetX = this.x;
                    this.targetY = this.y;
                }
            }

            /**
             * Stops dragging
             */
            stopDrag() {
                this.isDragging = false;
            }
        }

        // ==========================================
        // SPRING CONNECTION MODULE
        // ==========================================
        
        /**
         * Spring class represents curved connections between nodes
         */
        class Spring {
            constructor(nodeA, nodeB, diagramIndex) {
                this.nodeA = nodeA;
                this.nodeB = nodeB;
                this.diagramIndex = diagramIndex;
            }
            
            /**
             * Draws a bezier curve between two connected nodes
             */
            draw() {
                push();
                
                // Apply diagram offset
                translate(viewportOffset + poemDiagrams[this.diagramIndex].offsetX, 0);
                
                const minOpacity = min(this.nodeA.opacity, this.nodeB.opacity);
                stroke(100, 100, 100, minOpacity * 80);
                strokeWeight(1);
                
                const dx = this.nodeB.x - this.nodeA.x;
                const dy = this.nodeB.y - this.nodeA.y;
                const distance = sqrt(dx * dx + dy * dy);
                
                if (distance === 0) {
                    pop();
                    return;
                }
                
                // Calculate control points for bezier curve
                const controlOffset = distance * 0.2;
                const midX = (this.nodeA.x + this.nodeB.x) / 2;
                const midY = (this.nodeA.y + this.nodeB.y) / 2;
                
                const perpX = -dy / distance * controlOffset;
                const perpY = dx / distance * controlOffset;
                
                noFill();
                bezier(
                    this.nodeA.x, this.nodeA.y,
                    midX + perpX, midY + perpY,
                    midX - perpX, midY - perpY,
                    this.nodeB.x, this.nodeB.y
                );
                
                pop();
            }
        }

        // ==========================================
        // LAYOUT MANAGEMENT MODULE
        // ==========================================
        
        /**
         * LayoutManager handles different arrangement patterns for nodes
         * Static methods for circular, line, strophe, and poem layouts
         */
        class LayoutManager {
            /**
             * Arranges nodes in circular pattern (initial state)
             */
            static arrangeCircularForDiagram(diagram) {
                const centerX = windowWidth / 2;
                const centerY = windowHeight / 2;
                const radius = min(windowWidth, windowHeight) * 0.3;
                
                // forEach callback to position each node
                diagram.nodes.forEach((node, i) => {
                    if (node.type === 'poem') {
                        node.setTarget(centerX, centerY - radius * 0.7, 1.0);
                        node.initialX = centerX;
                        node.initialY = centerY - radius * 0.7;
                    } else {
                        const angle = (i / (diagram.nodes.length - 1)) * TWO_PI;
                        const r = random(radius * 0.3, radius);
                        const x = centerX + cos(angle) * r;
                        const y = centerY + sin(angle) * r;
                        node.setTarget(x, y, 1.0);
                        node.initialX = x;
                        node.initialY = y;
                    }
                    node.isOrdered = false;
                });
            }

            /**
             * Arranges line and its words horizontally
             */
            static arrangeLineLayoutForDiagram(diagram, lineNode) {
                // forEach callback to reset all nodes
                diagram.nodes.forEach(node => {
                    node.setTarget(node.initialX, node.initialY, 0.5);
                    node.isOrdered = false;
                });
                
                const centerY = windowHeight / 2;
                const startX = windowWidth * 0.2;
                
                lineNode.setTarget(startX, centerY, 1.0);
                lineNode.isOrdered = true;
                
                // forEach callback to arrange words
                lineNode.connections.forEach((wordNode, i) => {
                    const wordX = startX + 150 + (i * 80);
                    wordNode.setTarget(wordX, centerY, 1.0);
                    wordNode.isOrdered = true;
                });
            }

            /**
             * Arranges strophe with lines and words hierarchically
             */
            static arrangeStropheLayoutForDiagram(diagram, stropheNode) {
                // forEach callback to reset nodes
                diagram.nodes.forEach(node => {
                    node.setTarget(node.initialX, node.initialY, 0.5);
                    node.isOrdered = false;
                });
                
                const centerY = windowHeight / 2;
                const startX = windowWidth * 0.1;
                
                stropheNode.setTarget(startX, centerY - 50, 1.0);
                stropheNode.isOrdered = true;
                
                // forEach callback for lines
                stropheNode.connections.forEach((lineNode, lineIndex) => {
                    const lineY = centerY + (lineIndex * 60);
                    lineNode.setTarget(startX + 200, lineY, 1.0);
                    lineNode.isOrdered = true;
                    
                    // Nested forEach for words in each line
                    lineNode.connections.forEach((wordNode, wordIndex) => {
                        const wordX = startX + 350 + (wordIndex * 70);
                        wordNode.setTarget(wordX, lineY, 1.0);
                        wordNode.isOrdered = true;
                    });
                });
            }

            /**
             * Arranges entire poem hierarchy
             */
            static arrangePoemLayoutForDiagram(diagram) {
                const poemNode = diagram.nodes.find(n => n.type === 'poem');
                const startY = windowHeight * 0.1;
                let currentY = startY;
                
                poemNode.setTarget(windowWidth / 2, startY, 1.0);
                poemNode.isOrdered = true;
                currentY += 80;
                
                // forEach callback for strophes
                poemNode.connections.forEach((stropheNode, stropheIndex) => {
                    stropheNode.setTarget(windowWidth * 0.1, currentY, 1.0);
                    stropheNode.isOrdered = true;
                    
                    const stropheStartY = currentY;
                    
                    // forEach callback for lines in strophe
                    stropheNode.connections.forEach((lineNode, lineIndex) => {
                        const lineY = stropheStartY + (lineIndex * 50);
                        lineNode.setTarget(windowWidth * 0.25, lineY, 1.0);
                        lineNode.isOrdered = true;
                        
                        // forEach callback for words in line
                        lineNode.connections.forEach((wordNode, wordIndex) => {
                            const wordX = windowWidth * 0.4 + (wordIndex * 65);
                            wordNode.setTarget(wordX, lineY, 1.0);
                            wordNode.isOrdered = true;
                        });
                    });
                    
                    currentY += stropheNode.connections.length * 50 + 40;
                });
                
                // forEach to set unordered nodes to low opacity
                diagram.nodes.forEach(node => {
                    if (!node.isOrdered) {
                        node.setTarget(node.initialX, node.initialY, 0.5);
                    }
                });
            }
        }

        // ==========================================
        // DIAGRAM CREATION MODULE
        // ==========================================
        
        /**
         * Creates all nodes for a specific diagram
         */
        function createNodesForDiagram(diagram, diagramIndex) {
            diagram.nodes = [];
            
            // Create poem supernode
            diagram.nodes.push(new Node(
                windowWidth/2, 
                windowHeight/2, 
                'here this is the poem', 
                'poem', 
                'poem', 
                diagramIndex
            ));
            
            // Create strophe nodes - forEach callback
            Object.keys(diagram.data.strophes).forEach(strophe => {
                diagram.nodes.push(new Node(
                    0, 0, 
                    `Strophe ${strophe}`, 
                    'strophe', 
                    strophe, 
                    diagramIndex
                ));
            });
            
            // Create line nodes - forEach callback
            Object.keys(diagram.data.lines).forEach(lineId => {
                const line = diagram.data.lines[lineId];
                diagram.nodes.push(new Node(
                    0, 0, 
                    `Line ${line.strophe}-${line.line}`, 
                    'line', 
                    lineId, 
                    diagramIndex
                ));
            });
            
            // Create word nodes - forEach callback
            diagram.data.words.forEach((word, i) => {
                diagram.nodes.push(new Node(
                    0, 0, 
                    word.text, 
                    'word', 
                    `${word.lineId}-${i}`, 
                    diagramIndex
                ));
            });
        }
        
        /**
         * Creates spring connections between related nodes
         */
        function createConnectionsForDiagram(diagram) {
            diagram.springs = [];
            
            const poemNode = diagram.nodes.find(n => n.type === 'poem');
            
            // Connect poem to strophes - forEach callback
            diagram.nodes.forEach(node => {
                if (node.type === 'strophe') {
                    diagram.springs.push(new Spring(poemNode, node, node.diagramIndex));
                    poemNode.connections.push(node);
                }
            });
            
            // Connect strophes to lines - nested forEach callbacks
            diagram.nodes.forEach(stropheNode => {
                if (stropheNode.type === 'strophe') {
                    diagram.nodes.forEach(lineNode => {
                        if (lineNode.type === 'line') {
                            const lineData = diagram.data.lines[lineNode.id];
                            if (lineData && lineData.strophe == stropheNode.id) {
                                diagram.springs.push(new Spring(
                                    stropheNode, 
                                    lineNode, 
                                    stropheNode.diagramIndex
                                ));
                                stropheNode.connections.push(lineNode);
                            }
                        }
                    });
                }
            });
            
            // Connect lines to words - nested forEach callbacks
            diagram.nodes.forEach(lineNode => {
                if (lineNode.type === 'line') {
                    diagram.nodes.forEach(wordNode => {
                        if (wordNode.type === 'word') {
                            const wordData = diagram.data.words.find(
                                w => `${w.lineId}-${diagram.data.words.indexOf(w)}` === wordNode.id
                            );
                            if (wordData && wordData.lineId === lineNode.id) {
                                diagram.springs.push(new Spring(
                                    lineNode, 
                                    wordNode, 
                                    lineNode.diagramIndex
                                ));
                                lineNode.connections.push(wordNode);
                            }
                        }
                    });
                }
            });
        }

        // ==========================================
        // MAIN APPLICATION MODULE
        // ==========================================
        
        let floatingAnim;
        let draggedNode = null;
        let circularSlider;
        
        /**
         * p5.js setup function - initializes canvas and all components
         */
        function setup() {
            createCanvas(windowWidth, windowHeight);
            
            // Set center positions for circular slider
            CONFIG.circularSlider.centerX = windowWidth / 2;
            CONFIG.circularSlider.centerY = windowHeight / 2;
            
            // Initialize components
            floatingAnim = new FloatingAnimation();
            circularSlider = new CircularSlider();
            initializeAllPoems();
        }
        


        /**
         * p5.js draw function - main animation loop
         */
        function draw() {
            background(250);
            
            // Update components
            floatingAnim.update();
            circularSlider.update();
            
            // Smooth viewport transition for poem navigation
            viewportOffset = lerp(viewportOffset, targetOffset, CONFIG.animation.transitionSpeed);
            
            // Update and draw all poem diagrams - forEach callback
            poemDiagrams.forEach(diagram => {
                // Update nodes
                diagram.nodes.forEach(node => node.update());
                
                // Draw connections
                diagram.springs.forEach(spring => spring.draw());
                
                // Draw nodes
                diagram.nodes.forEach(node => node.draw());
            });
            
            // Draw circular slider on top
            circularSlider.draw();
            
            // Update current poem index based on viewport
            currentPoemIndex = round(-viewportOffset / windowWidth);
            currentPoemIndex = constrain(currentPoemIndex, 0, poemDiagrams.length - 1);
        }
        
        /**
         * Mouse press handler - manages both slider and node interactions
         */
        function mousePressed() {
            // First, check if circular slider handle was clicked
            circularSlider.onMousePressed();
            
            // If slider is being dragged, don't interact with nodes
            if (circularSlider.isDragging) return;
            
            // Handle node interactions
            const currentDiagram = poemDiagrams[currentPoemIndex];
            let clickedNode = null;
            
            // Find clicked node - for loop with early termination
            for (let node of currentDiagram.nodes) {
                if (node.contains(mouseX, mouseY)) {
                    clickedNode = node;
                    break;
                }
            }
            
            // Process clicked node based on type and current state
            if (clickedNode) {
                draggedNode = clickedNode;
                clickedNode.startDrag(mouseX, mouseY);
                
                // State management with if-else logic
                if (clickedNode.type === 'line' && currentDiagram.currentState !== 'line') {
                    currentDiagram.currentState = 'line';
                    LayoutManager.arrangeLineLayoutForDiagram(currentDiagram, clickedNode);
                } else if (clickedNode.type === 'strophe' && currentDiagram.currentState !== 'strophe') {
                    currentDiagram.currentState = 'strophe';
                    LayoutManager.arrangeStropheLayoutForDiagram(currentDiagram, clickedNode);
                } else if (clickedNode.type === 'poem' && currentDiagram.currentState !== 'poem') {
                    currentDiagram.currentState = 'poem';
                    LayoutManager.arrangePoemLayoutForDiagram(currentDiagram);
                } else if (clickedNode === currentDiagram.selectedNode) {
                    // Same node clicked again - reset to circular layout
                    currentDiagram.currentState = 'initial';
                    LayoutManager.arrangeCircularForDiagram(currentDiagram);
                    currentDiagram.selectedNode = null;
                    return;
                } else {
                    // Different node clicked - switch to new layout
                    if (clickedNode.type === 'line') {
                        currentDiagram.currentState = 'line';
                        LayoutManager.arrangeLineLayoutForDiagram(currentDiagram, clickedNode);
                    } else if (clickedNode.type === 'strophe') {
                        currentDiagram.currentState = 'strophe';
                        LayoutManager.arrangeStropheLayoutForDiagram(currentDiagram, clickedNode);
                    } else if (clickedNode.type === 'poem') {
                        currentDiagram.currentState = 'poem';
                        LayoutManager.arrangePoemLayoutForDiagram(currentDiagram);
                    }
                }
                currentDiagram.selectedNode = clickedNode;
            } else {
                // Clicked outside - reset to circular layout
                currentDiagram.currentState = 'initial';
                LayoutManager.arrangeCircularForDiagram(currentDiagram);
                currentDiagram.selectedNode = null;
            }
        }

        /**
         * Mouse drag handler - updates slider or node position
         */
        function mouseDragged() {
            // Update slider if being dragged
            circularSlider.onMouseDragged();
            
            // Update node if being dragged
            if (draggedNode) {
                draggedNode.updateDrag(mouseX, mouseY);
            }
        }

        /**
         * Mouse release handler - stops all dragging
         */
        function mouseReleased() {
            circularSlider.onMouseReleased();
            
            if (draggedNode) {
                draggedNode.stopDrag();
                draggedNode = null;
            }
        }
        
        /**
         * Window resize handler - recalculates all positions
         */
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            
            // Update slider center position
            CONFIG.circularSlider.centerX = windowWidth / 2;
            CONFIG.circularSlider.centerY = windowHeight / 2;
            circularSlider.centerX = CONFIG.circularSlider.centerX;
            circularSlider.centerY = CONFIG.circularSlider.centerY;
            
            // Recalculate poem points
            circularSlider.poemPoints = circularSlider.poemAngles.map(angle => ({
                x: circularSlider.centerX + cos(angle) * circularSlider.radius,
                y: circularSlider.centerY + sin(angle) * circularSlider.radius,
                angle: angle
            }));
            
            // Reinitialize poems
            initializeAllPoems();
        }
    </script>
</body>
</html>